# 总结

本章我们使用`ReactiveCocoa`做了很多实践，总结了几个关键点：

- 函数式编程可在任何地方起作用
	- 数据导入的代码，即使没有反应式代码，我们也能够使用`map:`和`filter:`来帮忙。在抽象方面，总觉得从未被实际实现。


- 为函数的副作用使用`subscribeNext:`
	- `subscribeNext:`和其他类似的方法订阅信号的副作用，返回`RACDisposable`实例（这种实例将被传阅，直到信号完成被回收为止）
为副作用使用这些方法---使得事物看起来像主动跟外界(一个没有反应式的世界)交互似的。


- 避免显示状态下进行订阅处理
   - 按照设计准则，无论何时都应该避免显示的订阅处理。请记住我们是怎样用`takeUntil:`来自动处理`FRPCell`类的订阅的。使用`takeUntil:`允许信号值通过，直到它的参数被传递下去或者它自己的值完成。基本上这种情况下，接收者已经完成接收了。

- 内存管理的魔法
  - ARC下，在代码的表面上你摆脱了内存管理。`ReactiveCocoa`中也一样。唯一要注意的是，不能在任何signal的block中捕捉self。

以上，就是第五章的全部内容。接下来我们将介绍Model-View-ViewModel这种程序架构，给App添加一个日志系统，并写一些单元测试，出发吧！


> BTY:函数副作用：指当调用函数时，除了返回函数值之外，还对主调用函数产生附加影响。例如修改全局变量或修改参数，一般而言函数副作用会给程序设计带来不必要的麻烦，使程序难以查找错误，并降低程序的可读性。严格的函数式语言要求函数必须无副作用。
> 有一种特殊的情况，就是我们这里的函数。它的参数是一种In/Out作用的参数，即函数可能改变参数里面的内容，把一些信息通过输入参数，夹带到外界。这种情况，严格来说，也是副作用，是非纯函数。即我们所讨论的函数反应型编程中的函数式编程属于非纯函数，它是具有副作用的。
